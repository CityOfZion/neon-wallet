// @flow
import React, { useContext, useEffect } from 'react'
import { BSNeo3 } from '@cityofzion/bs-neo3'

import { getStorage, setStorage } from '../../core/storage'

export type ContactInfo = {
  address: string,
  chain: string,
  // this key is dynamic and based on the current
  // response of the NNS contract at runtime
  parsedAddress?: string,
}

export type Contacts = {
  [name: string]: ContactInfo[],
}

export type DeprecatedContact = {
  [name: string]: string,
}

type ContactsContextType = {
  contacts: Contacts,
  updateContacts: (contactName: string, data: ContactInfo[]) => Promise<any>,
  deleteContact: (contactName: string) => Promise<any>,
}

const STORAGE_KEY = 'multi-chain-address-book'

const DEPRECATED_STORAGE_KEY = 'addressBook'
const DEPRECATED_N3_STORAGE_KEY = 'n3AddressBook'

export const ContactsContext = React.createContext<ContactsContextType>({})
export const useContactsContext = () => useContext(ContactsContext)

export const ContactsContextProvider = ({
  children,
}: {
  children: React$Node,
}) => {
  const [contacts, setContacts] = React.useState({})

  const getContacts = async (): Promise<Contacts> => {
    const contacts = await getStorage(STORAGE_KEY)
    const deprecatedLegacyContacts = await getStorage(DEPRECATED_STORAGE_KEY)
    const deprecatedN3Contacts = await getStorage(DEPRECATED_N3_STORAGE_KEY)
    // transform the deprecated contacts into the new format
    const newContacts = {}
    // eslint-disable-next-line guard-for-in
    for (const contactName in deprecatedLegacyContacts) {
      const contactAddress = deprecatedLegacyContacts[contactName]
      if (typeof contactAddress === 'string') {
        newContacts[contactName] = [{ address: contactAddress, chain: 'neo2' }]
      }
    }
    // eslint-disable-next-line guard-for-in
    for (const contactName in deprecatedN3Contacts) {
      const contactAddress = deprecatedN3Contacts[contactName]
      if (typeof contactAddress === 'string') {
        newContacts[contactName] = [{ address: contactAddress, chain: 'neo3' }]
      }
    }
    return { ...contacts, ...newContacts }
  }

  const saveContacts = async (contacts: Contacts): Promise<any> =>
    setStorage(STORAGE_KEY, contacts)

  async function fetchPotentialNameServiceAddresses(contacts: Contacts) {
    try {
      const NeoBlockChainService = new BSNeo3()
      const newContacts = {}
      // eslint-disable-next-line guard-for-in
      for (const contactName in contacts) {
        const contactInfo = contacts[contactName]
        const newContactInfo = []
        for (const contact of contactInfo) {
          const { address, chain } = contact
          let parsedAddress
          if (address.includes('.neo')) {
            const results = await NeoBlockChainService.getOwnerOfNNS(address)
            parsedAddress = results
          }
          newContactInfo.push({ address, chain, parsedAddress })
        }
        newContacts[contactName] = newContactInfo
      }
      setContacts(newContacts)
    } catch (e) {
      console.error(e)
      setContacts(contacts)
    }
  }

  const updateContacts = async (contactName: string, data: ContactInfo[]) => {
    // scrub the data of all parsedAddress fields
    const scrubbedData = data.map(contact => {
      const { parsedAddress, ...rest } = contact
      return rest
    })
    const contacts = await getContacts()
    const newContacts = { ...contacts, [contactName]: scrubbedData }
    await saveContacts(newContacts)
    await fetchPotentialNameServiceAddresses(newContacts)
  }

  const deleteContact = async (contactName: string) => {
    const contacts = await getContacts()
    const newContacts = { ...contacts }
    delete newContacts[contactName]
    await saveContacts(newContacts)
    await fetchPotentialNameServiceAddresses(newContacts)
  }

  useEffect(() => {
    const init = async () => {
      const contacts = await getContacts()
      await fetchPotentialNameServiceAddresses(contacts)
    }
    init()
  }, [])

  const contextValue = {
    updateContacts,
    deleteContact,
    contacts,
  }

  return (
    <ContactsContext.Provider value={contextValue}>
      {children}
    </ContactsContext.Provider>
  )
}
